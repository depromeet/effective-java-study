# Item 86. Serializable을 구현할지는 신중히 결정하라

어떤 클래스의 인스턴스를 직렬화할 수 있게 하려면 클래스 선언에 implements Serializable만 덧붙이면 된다.

> 하지만 아주 신중하게 이뤄져야하며, 상송할 수 있는 클래스라면 주의사항이 더욱 많아진다

**간단한 예시**

```java
import java.io.Serializable;

public class Employee implements Serializable {
    private static final long serialVersionUID = 1L;

    private String name;
    private int age;

    // 생성자, getter, setter 등 다른 코드
}
```

_하지만 이를 구현할지 여부는 신중히 결정해야 하는데, 여기에는 여러 이유가 있다_

**보안 문제**:

-   직렬화와 역직렬화 과정에서는 그 과정이 완벽히 제어될 수 없다
-   이로 인해 시스템의 보안을 해칠 가능성이 있다
-   역직렬화하는 동안 악의적으로 조작된 인스턴스가 생성될 수 있고, 이는 시스템의 보안을 침해할 수 있다

**버그와 문제점**:

-   Serializable 인터페이스를 구현하는 것은 해당 클래스의 인스턴스를 직렬화/역직렬화 가능하게 하지만, 이는 항상 완벽하게 동작하는 것이 아니다
-   객체의 복잡한 상태를 바이트 스트림으로 변환하거나 반대로 수행하는 것은 버그를 유발할 수 있다

**설계 및 유지 보수 문제**:

-   직렬화를 허용하게 되면 해당 클래스에 대한 변경 사항을 제한하게 된다
-   왜냐하면 직렬화된 형태를 지원하기 위해 이전 버전의 클래스와의 호환성을 유지해야하기 때문
-   이는 클래스 설계를 제한하며, 유지 보수를 어렵게 만들 수 있다

<br/>

### 특히 상속용으로 설계된 클래스(아이템 19)는 대부분 Serializable을 구현하면 안된다

-   Serializable을 구현하게 되면 이는 클래스의 하위 호환성을 지원해야 함을 의미한다
-   이로 인해 클래스의 설계와 구현에 제약이 생긴다
-   상속용으로 설계된 클래스가 Serializable을 구현하게 되면, 이 클래스를 상속하는 하위 클래스들은 자동적으로 직렬화가 가능해진다
-   하지만 이렇게 되면 하위 클래스는 상위 클래스가 Serializable 인터페이스를 구현한 것에 따른 부작용을 무조건적으로 상속받게 된다
-   이로 인해 하위 클래스를 올바르게 설계하거나 유지 관리하는 것이 더 어려워질 수 있다

<br/>

### 또한, 인터페이스도 대부분 Serializable을 확장해서는 안된다

-   인터페이스 또한, 인터페이스가 Serializable을 확장하게 되면, 이 인터페이스를 구현하는 모든 클래스들이 자동적으로 Serializable을 구현하게 됨

<br/>

### 그럼에도 Serializable을 구현하거나 확장해야 하는 경우는?

-   그럼에도 불구하고, 모든 클래스나 인터페이스가 Serializable을 구현하거나 확장하지 않아야 하는 것은 아니다
-   예를 들어, 직렬화가 중요한 도메인 객체나 DTO(Data Transfer Object)는 Serializable을 구현해야 할 수도 있다

-   또한, 컬렉션 인터페이스들과 같이, 그 인터페이스를 구현하는 객체들이 일반적으로 직렬화될 것으로 기대되는 인터페이스는 Serializable을 확장해야 할 수도 있다
-   예를 들어, java.util.List와 같은 인터페이스는 Serializable을 확장한다
-   왜냐하면 대부분의 경우 리스트의 인스턴스는 직렬화해야 하는 경우가 많기 때문이다

<br/>

### 내부 클래스(아이템 24)는 직렬화를 구현하지 말아야 한다

-   내부 클래스에는 바깥 인스턴스의 참조화 유효 범위 안의 지역변수 값들을 저장하기 위해 컴파일러가 생성한 필드들이 자동으로 추가된다
-   익명 클래스와 지역 클래스의 이름을 짓는 규칙이 언어 명세에 나와 있지 않듯, 이 필드들의 이름도 언어 명세에 나와 있지 않다

<br/>

-   예를 들어, 익명 클래스 인스턴스를 외부에 전달하거나, 파일에 저장하거나, 네트워크를 통해 전송해야 하는 상황에서는 그 인스턴스가 직렬화 가능해야 한다
-   이런 상황에서 직렬화를 구현하면 문제가 생길 수 있다.

-   그리고 익명 클래스나 지역 클래스가 직렬화 가능하다면, 그 인스턴스의 필드는 그 클래스의 "이름없는" 외부 클래스를 참조할 수 있다
-   이는 데이터 읽기 및 쓰기 시스템에서 복잡성을 증가시키고, 버그를 유발할 수 있다

-   따라서, 일회성으로 사용되는 익명 클래스나 지역 클래스가 직렬화를 구현할 필요가 있다면, 그 대신 별도의 정적 내부 클래스를 선언하여 이를 사용하는 것이 좋다
-   이 방법은 클래스의 이름 지정과 클래스와 필드의 관계를 명확하게 만들어주므로, 이런 문제를 피할 수 있다
